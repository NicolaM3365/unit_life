"""
Unit 5 Walk through
Databases

Creating databases tables

Django has a default Object Relational Mapper(ORM) built in.
The ORM allows the use of different databases.
For example you might use SQLite for development and PostgreSQL for production.
The ORM handles the differences allowing the code to remain the same.

The Django ORM allows us to represent our databases tables using model classes,
very similarly to the way we've done it in SQLAlchemy.

#
#

1. Inside the the blog app directory we have a file called models.py.

├── blog
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── __init__.py
│   ├── models.py
│   ├── static
│   │   └── blog
│   │       └── main.css
│   ├── templates
│   │   └── blog
│   │       ├── about.html
│   │       ├── base.html
│   │       └── home.html
│   ├── tests.py
│   ├── urls.py
│   └── views.py

#
#

2. Open models.py You will see the following
"""
from django.db import models

# Create your models here.

"""

#
#

3. We need to think about what models we want e.g users, post etc.
For this lesson, will start with our first custom model - Post.

We'll need to create class named Post with the following attributes (each representing a column):
    title - a varchar of length <=100
    content - a text field (with arbitrary length)
    date_posted - a datetime field defaulting to the creation time

To achieve this, change your posts/models.py file to the following code:
"""
from django.db import models
from django.utils import timezone

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    date_posted = models.DateTimeField(default=timezone.now)

"""
-> from django.utils import timezone --> Imports django's timezone module from django.utils

-> title = models.CharField(max_length=100) --> This sets a title attribute of the character type with a max length of 100.
-> content = models.TextField() --> Sets a content attribute to the TextField type.
-> date_posted = models.DateTimeField(default=timezone.now) --> Sets date_posted attribute to the current default timezone

Another option for date_posted would be to set date_posted = models.DateTimeField(auto_now_add=True)
This will work when the object is created but does not allow the date to be changed after creation.

The models.DateTimeField(default=timezone.now) does allow this.

#
#

4. Add an author attribute to the Post class. This is for the User that creates each post.
The User is a separate table so we need to import the User. At the top od models.py add the import
"""
from django.contrib.auth import get_user_model
User = get_user_model()

"""
The User to Post relationship will be 1 to Many as 1 User can have multiple posts. In Django we can
specify the 1 to M with a foreign key relationship.

#
#

5. Add 1 to M relationship and set that if a user is deleted all their posts are also removed.
"""
class Post(models.Model):
    ...
    author = models.ForeignKey(User, on_delete=models.CASCADE)
"""
#
#

6. models.py should now have the following code.
"""
from django.db import models
from django.utils import timezone
from django.contrib.auth import get_user_model
User = get_user_model()

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    date_posted = models.DateTimeField(default=timezone.now)
    author = models.ForeignKey(User, on_delete=models.CASCADE)
"""

#
#

7. Update the changes using make migrations. From the command line run

python manage.py makemigrations

	Output...

	Migrations for 'blog':
	  blog/migrations/0001_initial.py
	    - Create model Post

#
#

8. To see the changes open 0001_initial.py.

├── blog
│   ├── __init__.
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── __init__.py

Do not change the code directly from here. You will something similar to the following code.

	# Generated by Django 4.2.3 on 2023-07-18 14:36

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="Post",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("title", models.CharField(max_length=100)),
                ("content", models.TextField()),
                (
                    "date_posted",
                    models.DateTimeField(default=django.utils.timezone.now),
                ),
                (
                    "author",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
        ),
    ]

#
#

9. To view the SQL that will be created from the class Post in models.py use the following command

python manage.py sqlmigrate blog 0001

This can be great if you need to see the exact SQL that is used. The SQL should look similar to the code below.

			BEGIN;
	--
	-- Create model Post
	--
	CREATE TABLE "blog_post" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "title" varchar(100) NOT NULL, "content" text NOT NULL, "date_posted" datetime NOT NULL, "author_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED);
	CREATE INDEX "blog_post_author_id_dd7a8485" ON "blog_post" ("author_id");
	COMMIT;

Django has created this from the class giving the developer an abstraction from having
to deal with the database directly. This can save time in development.

#
#

10. Migrate the changes from the command line with the following command

python manage.py migrate

	Output...

	Operations to perform:
  Apply all migrations: admin, auth, blog, contenttypes, sessions
Running migrations:
  Applying blog.0001_initial... OK


Note: Migrations are very useful because we can make changes to the Database without having to
work directly with the SQL

#
#

11. Interact with the database via a python shell. Run the following command from the CLI.

python manage.py shell

#
#

12. Inside the shell import the classes.

>>> from blog.models import Post
>>> from django.contrib.auth import get_user_model
>>> User = get_user_model()
#
#

13. We have created two Users and we can view them with the following command.

>>> User.objects.all()
<QuerySet [<User: stevek>, <User: TestUserUCDPA>]>

#
#

14. To see the first user created.

>>> User.objects.first()
<User: stevek>

#
#

15. filter(). Can be used to filter the Queryset. Example below.

>>> User.objects.filter(username='stevek')
<QuerySet [<User: stevek>]>

#
#

16. Storing a filter() inside a variable.

>>> user = User.objects.filter(username='stevek').first()
>>> user
<User: stevek>

#
#

17. Use the variable to access attributes and particualrly user.pk for the Primary Key

>>> user
<User: stevek>
>>> user.pk
1

#
#

18. get(). Below we are using get() to create a user varaibale based on the pk=1

>>> user = User.objects.get(pk=1)
>>> user
<User: stevek>

#
#

19. Check Posts. Posts will be currently empty.

>>> Post.objects.all()
<QuerySet []>

#
#

20. Create a post for <User: stevek>

>>> post_test_1 = Post(title='Blog One', content='This is my first post', author=user)

#
#

21. Run Post.objects.all(). You will see the query set is still empty as the post_test_1
object has not been saved to the database.

>>> Post.objects.all()
<QuerySet []>

#
#

22.Save the post and run Post.objects.all() to see the Post in the query set.

>>> post_test_1.save()
>>> Post.objects.all()
<QuerySet [<Post: Post object (1)>]>

#
#

23. Create a __str__ method in models.py to allow for a more desrciptive info on the object
Open Blog -> models.py and add the code below to the Post model.
"""
class Post(models.Model):
    ...
    def __str__(self):
        return self.title

"""

models.py should now have the following code.

	from django.db import models
	from django.utils import timezone
    from django.contrib.auth import get_user_model
    User = get_user_model()

	# Create your models here.
	class Post(models.Model):
	    title = models.CharField(max_length=100)
	    content = models.TextField()
	    date_posted = models.DateTimeField(default=timezone.now)
	    author = models.ForeignKey(User, on_delete=models.CASCADE)

	    def __str__(self):
	        return self.title

#
#

24. For the changes to take effect exit() the shell and reopen it with

python manage.py shell

Re-import the models...

>>> from blog.models import Post
>>> from django.contrib.auth import get_user_model
>>> User = get_user_model()

#
#

25. Run Post.objects.all() and now we see the blog title in the query set.

>>> Post.objects.all()
<QuerySet [<Post: Blog One>]>

#
#

26. Add the user variable again as this is not saved when
exiting the shell.

>>> user = User.objects.filter(username='stevek').first()
>>> user
<User: stevek>

#
#

27. Create another blog post.

>>> post_test_2 = Post(title='Blog Two', content='This is my second post', author=user)

Note: if you didn't have the user instance, but did have its pk in a variable called user_pk,
you could replace author=user with author_id=user_pk
#
#

28. Save the blog post to insert it into the database.

>>> post_test_2.save()
>>> Post.objects.all()
<QuerySet [<Post: Blog One>, <Post: Blog Two>]>

#
#

29. Fetch the first post.

>>> post = Post.objects.first()

#
#

30. Access the attributes of the post object

>>> post.content
'This is my first post'

>>> post.author
<User: stevek>

>>> post.date_posted
datetime.datetime(2023, 7, 18, 15, 21, 33, 794281, tzinfo=datetime.timezone.utc)

#
#

31. The post object is the entire object. We can access other details that are
not directly in the Post class of models.py.

For example to access the email and password(encrypted).

>>> post.author.email
'stephen.kohlmannucd@gmail.com'

>>> post.author.password
'pbkdf2_sha256$600000$5yas5LhYnccag4xVsTObQh$r8q0qqUMGMyjAjemPRqLCU8adjYonTAfF/m+hMO+BOg='

#
#

32. Get all posts written by a specfic user. Django has a special query set in the
user model .modelname_set. In our case the model name is post. Run the following...

>>> user.post_set

The output is not very useful as it stands below...

<django.db.models.fields.related_descriptors.create_reverse_many_to_one_manager.<locals>.RelatedManager object at 0x1031dfe10>

#
#

33. Run user.post_set.all()

>>> user.post_set.all()
<QuerySet [<Post: Blog One>, <Post: Blog Two>]>

Now we see the the posts by that user.

#
#

34. Create a new blog post with post_set.all()

>>> user.post_set.create(title='Blog 3', content='Third Post Content')
<Post: Blog 3>

Note: You do not need to save the post as the set.create automatically does this.
Also you don't need to specify an author as the user object is already defined
Django will save the post to this author.

#
#

35. Run Post.objects.all()

>>> Post.objects.all()
<QuerySet [<Post: Blog One>, <Post: Blog Two>, <Post: Blog 3>]>

#
#

36. Exit the shell (by running exit() or Ctrl+D) and Open Blog -> views.py
Inside views.py add an import for the Post class
"""
from .models import Post

"""

#
#

37. Update the home view

from ...

def home(request):
    context = {
        'posts': posts
    }
    return render(request, 'blog/home.html', context)

to ...
"""

def home(request):
    context = {
       'posts': Post.objects.all()
    }
    return render(request, 'blog/home.html', context)
"""

#
#

38. Run the development server and now you will see three blog posts
and the date formatting from the database.

python manage.py runserver

#
#

39. Currently the the date created is showing the timestamp.
This can be useful for certain applications but for now we will
change the format using Django Date Formatting.

Refer to https://docs.djangoproject.com/en/4.2/ref/templates/builtins/#date

#
#

40. Open Blog -> templates -> blog -> home.html

Update {{ post.date_posted }}

from ...

<small class="text-muted">{{ post.date_posted }}</small>

to ...

{{ post.date_posted|date:'dS, F, Y' }}

Template tags have a filters. Above we are using the date filter and specifying the
format in a string as d = date, S = suffix ('st', 'nd', 'rd' or 'th),
F =  Full Month, Y = Full Year

#
#

41. Delete the dummy data fro the in blog -> views.py

The dummy data was...

posts = [
    {
        'author': 'Steve K',
        'title': 'First Blog Post',
        'content': 'Content for the first post.',
        'date_posted': '12/07/2023'
    },

     {
        'author': 'Scott K',
        'title': 'Second Blog Post',
        'content': 'Content for the second post.',
        'date_posted': '13/07/2023'
    }
]

views.py when updated should now look like the following
"""

from django.shortcuts import render
from django.http import HttpResponse
from .models import Post

def home(request):
    context = {
       'posts': Post.objects.all()
    }
    return render(request, 'blog/home.html', context)

def about(request):
    return render(request, 'blog/about.html', {'title': 'About'})

"""

#
#

42. Use the admin GUI to update the Posts.
For this we need to register Posts with the admin page.
Before doing this open up the admin page http://127.0.0.1:8000/admin/

Under AUTHENTICATION AND AUTHORIZATION you will see

Groups
Users

#
#

43. Open blog -> admin.py

Inside admin.py you will see

	from django.contrib import admin

	# Register your models here.

#
#

44. Register the model to admin page as follows.
"""

from django.contrib import admin
from .models import Post

admin.site.register(Post)
"""

Save the file and reload the browser. At this point you will see.

Blog
Posts

Go into Posts and you will see Blog 1, Blog 2 , Blog 3

You can now perform CRUD.

This is a very powerful feature of Django allowing back-end functionality
via the GUI.
"""
